//! Connection state types used by the RakNet session layer.
//!
//! These enums model high-level connection lifecycle and reasons for
//! transitions, some of which are serialised on the wire.

use bytes::{Buf, BufMut};

use crate::protocol::packet::{DecodeError, RaknetEncodable};

/// High-level connection state for an online RakNet session.
#[repr(u8)]
pub enum ConnState {
    /// No connection established.
    Unconnected,
    /// Performing the connection handshake.
    Connecting,
    /// Connected and ready for user data.
    Connect,
    /// In the process of shutting down.
    Disconnecting,
    /// Connection fully torn down.
    Disconnected,
}

/// Offline (pre-connection) handshake state.
#[repr(u8)]
pub enum OfflineState {
    /// Initial unconnected ping handshake.
    Handshake1,
    /// MTU / connection request negotiation.
    Handshake2,
    /// Offline handshake completed.
    HandshakeCompleted,
}

/// Reason codes sent with certain disconnect/control packets.
#[derive(Debug, Clone, Copy)]
#[repr(u8)]
pub enum DisconnectReason {
    ClosedByRemotePeer,
    ShuttingDown,
    Disconnected,
    TimedOut,
    ConnectionRequestFailed,
    AlreadyConnected,
    NoFreeIncomingConnections,
    IncompatibleProtocolVersion,
    IPRecentlyConnected,
    BadPacket,
    QueueTooLong,
}

impl RaknetEncodable for DisconnectReason {
    fn encode_raknet(&self, dst: &mut impl BufMut) {
        (*self as u8).encode_raknet(dst);
    }

    fn decode_raknet(src: &mut impl Buf) -> Result<Self, DecodeError> {
        let v = u8::decode_raknet(src)?;
        let e = match v {
            0 => DisconnectReason::ClosedByRemotePeer,
            1 => DisconnectReason::ShuttingDown,
            2 => DisconnectReason::Disconnected,
            3 => DisconnectReason::TimedOut,
            4 => DisconnectReason::ConnectionRequestFailed,
            5 => DisconnectReason::AlreadyConnected,
            6 => DisconnectReason::NoFreeIncomingConnections,
            7 => DisconnectReason::IncompatibleProtocolVersion,
            8 => DisconnectReason::IPRecentlyConnected,
            9 => DisconnectReason::BadPacket,
            10 => DisconnectReason::QueueTooLong,
            _ => return Err(DecodeError::UnknownDisconnectReason(v)),
        };
        Ok(e)
    }
}

/// High-level events generated by the protocol layer.
#[repr(u8)]
pub enum Event {
    /// A new incoming connection has been fully established.
    NewIncomingConnection,
}

#[cfg(test)]
mod tests {
    use super::*;
    use bytes::BytesMut;

    #[test]
    fn disconnect_reason_roundtrip() {
        for reason in [
            DisconnectReason::ClosedByRemotePeer,
            DisconnectReason::TimedOut,
            DisconnectReason::QueueTooLong,
        ] {
            let mut buf = BytesMut::new();
            reason.encode_raknet(&mut buf);
            let mut slice = buf.freeze();
            let decoded = DisconnectReason::decode_raknet(&mut slice).unwrap();
            // encode as u8 again and compare discriminants
            let mut orig_buf = BytesMut::new();
            reason.encode_raknet(&mut orig_buf);
            let mut orig_slice = orig_buf.freeze();
            let orig_u8 = u8::decode_raknet(&mut orig_slice).unwrap();
            let mut dec_buf = BytesMut::new();
            decoded.encode_raknet(&mut dec_buf);
            let mut dec_slice = dec_buf.freeze();
            let dec_u8 = u8::decode_raknet(&mut dec_slice).unwrap();
            assert_eq!(orig_u8, dec_u8);
        }
    }
}
